#include <google/protobuf/util/message_differencer.h>
#include <igasync/promise_combiner.h>
#include <igcore/log.h>
#include <imgui.h>
#include <nfd.h>
#include <views/navmesh_params_view.h>

using namespace indigo;
using namespace core;
using namespace mapeditor;

namespace {
const char* kLogLabel = "NavMeshParamsView";
const size_t kFullProtoTextBufferSize = 32000;

// https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf
// Released CC0 1.0 by author
template <typename... Args>
std::string string_format(const std::string& format, Args... args) {
  int size_s = std::snprintf(nullptr, 0, format.c_str(), args...) +
               1;  // Extra space for '\0'
  if (size_s <= 0) {
    throw std::runtime_error("Error during formatting.");
  }
  auto size = static_cast<size_t>(size_s);
  auto buf = std::make_unique<char[]>(size);
  std::snprintf(buf.get(), size, format.c_str(), args...);
  return std::string(buf.get(),
                     buf.get() + size - 1);  // We don't want the '\0' inside
}

static void HelpMarker(const char* desc) {
  ImGui::TextDisabled("(?)");
  if (ImGui::IsItemHovered()) {
    ImGui::BeginTooltip();
    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
    ImGui::TextUnformatted(desc);
    ImGui::PopTextWrapPos();
    ImGui::EndTooltip();
  }
}

}  // namespace

NavMeshParamsView::NavMeshParamsView(
    std::shared_ptr<RecastParams> recast_params,
    std::shared_ptr<RecastBuilder> recast_builder,
    std::shared_ptr<indigo::core::TaskList> async_task_list,
    std::shared_ptr<indigo::core::TaskList> main_thread_task_list)
    : recast_params_(recast_params),
      recast_builder_(recast_builder),
      cell_size_(recast_params->cell_size()),
      cell_height_(recast_params->cell_height()),
      max_slope_degrees_(recast_params->max_slope_degrees()),
      walkable_climb_(recast_params->walkable_climb()),
      walkable_height_(recast_params->walkable_height()),
      agent_radius_(recast_params->agent_radius()),
      min_region_area_(recast_params->min_region_area()),
      merge_region_area_(recast_params->merge_region_area()),
      max_contour_error_(recast_params->max_contour_error()),
      max_edge_length_(recast_params->max_edge_length()),
      detail_sample_distance_(recast_params->detail_sample_distance()),
      detail_max_error_(recast_params->detail_max_error()),
      recast_ops_(recast_params->recast_ops()),
      assimp_loader_(std::make_shared<AssimpLoader>()),
      async_task_list_(async_task_list),
      main_thread_task_list_(main_thread_task_list),
      is_valid_path_(false),
      full_proto_text_(new char[::kFullProtoTextBufferSize]),
      text_matches_(true),
      has_text_error_(false),
      is_loading_(false) {
  std::string asset_root = recast_params->asset_root().string();
  strcpy(asset_root_, asset_root.c_str());

  strcpy(full_proto_text_, recast_params->proto_text().c_str());
}

NavMeshParamsView::~NavMeshParamsView() { delete[] full_proto_text_; }

void NavMeshParamsView::render() {
  bool has_difference = false;
  std::vector<std::string> validation_errors;

  int delete_idx = -1;

  if (ImGui::InputText("Asset Root", asset_root_, 256)) {
    is_valid_path_ = std::filesystem::is_directory(asset_root_);
  }

  if (!is_valid_path_) {
    ImGui::Text("Invalid root directory");
  } else {
    std::string asset_root = recast_params_->asset_root().string();
    std::string gui_root = asset_root_;
    if (asset_root != gui_root) {
      if (ImGui::Button("Update Asset Root")) {
        recast_params_->asset_root(gui_root);
      }
    }
  }

  if (ImGui::TreeNode("Loaded Assimp files")) {
    std::vector<std::string> assimp_file_names = assimp_loader_->file_names();
    if (ImGui::Button("Add Assimp File")) {
      nfdchar_t* out_path = nullptr;
      nfdresult_t result = NFD_OpenDialog("fbx", nullptr, &out_path);

      if (result == NFD_OKAY) {
        assimp_loader_->load_file(out_path, async_task_list_,
                                  main_thread_task_list_);

        free(out_path);
      }
    }

    for (const auto& file_name : assimp_file_names) {
      if (assimp_loader_->is_loading(file_name)) {
        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(255, 85, 85, 255));
      } else {
        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(215, 255, 255, 255));
      }

      std::string full_key = file_name + "##assimp_file";
      if (ImGui::TreeNode(full_key.c_str())) {
        std::vector<std::string> mesh_names =
            assimp_loader_->mesh_names_in_loaded_file(file_name);

        for (const auto& name : mesh_names) {
          ImGui::Text(name.c_str());
        }

        ImGui::TreePop();
      }

      ImGui::PopStyleColor();
    }

    ImGui::TreePop();
  }

  if (ImGui::TreeNode("Recast generation parameters")) {
    ImGui::TextWrapped(
        "Detour navigation meshes are generated by passing input geometry "
        "through a set of transformations that ultimately results in a Detour "
        "navmesh that can be used by a client to make navigation decisions in "
        "space.\n\n3D input geometry creates a voxel field which is then "
        "trimmed down based on agent properties.\n\nThe voxel field is then "
        "used to generate a contour map, which is further used to generate "
        "actual navigation mesh geometry.");

    // Cell Size
    ImGui::InputFloat("Cell Size", &cell_size_);
    ImGui::SameLine();
    ::HelpMarker(
        "Width (in world units) of a Recast heightmap voxel - influences X/Z "
        "granularity of navmesh generation");
    if (cell_size_ != recast_params_->cell_size()) {
      has_difference = true;
    }

    // Cell Height
    ImGui::InputFloat("Cell Height", &cell_height_);
    ImGui::SameLine();
    ::HelpMarker(
        "Height (in world units) of a Recast heightmap voxel - influences Y "
        "granularity of navmesh generation");
    if (cell_height_ != recast_params_->cell_height()) {
      has_difference = true;
    }

    // Max slope degrees
    ImGui::InputFloat("Max Slope (degrees)", &max_slope_degrees_);
    ImGui::SameLine();
    ::HelpMarker(
        "Maximum slope the agent can climb, in degrees. Polygons more sharply "
        "angled than this will be considered unwalkable and excluded from the "
        "navigation mesh.");
    if (max_slope_degrees_ != recast_params_->max_slope_degrees()) {
      has_difference = true;
    }

    // Walkable climb
    ImGui::InputFloat("Walkable Climb", &walkable_climb_);
    ImGui::SameLine();
    ::HelpMarker(
        "Maximum distance the agent can climb from one point to the next - "
        "basically how tall can a stair step be before the agent isn't able to "
        "climb it? Eventually expressed in terms of cell_height.");
    if (walkable_climb_ != recast_params_->walkable_climb()) {
      has_difference = true;
    }

    // Walkable height
    ImGui::InputFloat("Walkable Height", &walkable_height_);
    ImGui::SameLine();
    ::HelpMarker(
        "Hitbox height of the agent - an agent cannot enter a space where the "
        "distance from floor to ceiling is smaller than this number. "
        "Eventually expressed in terms of cell_height.");
    if (walkable_height_ != recast_params_->walkable_height()) {
      has_difference = true;
    }

    // Agent radius
    ImGui::InputFloat("Agent Radius", &agent_radius_);
    ImGui::SameLine();
    ::HelpMarker(
        "Hitbox radius of the agent - the navigation mesh will be eroded away "
        "from non-navigatable edges by this amount so that agents do not clip "
        "through geometry.");
    if (agent_radius_ != recast_params_->agent_radius()) {
      has_difference = true;
    }

    // Min region area
    ImGui::InputFloat("Min Region Area", &min_region_area_);
    ImGui::SameLine();
    ::HelpMarker(
        "Minimum region area, in square world units. Any navmesh region "
        "smaller than this will not be added to the final navmesh. Eventually "
        "expressed in terms of cell width.");
    if (min_region_area_ != recast_params_->min_region_area()) {
      has_difference = true;
    }

    // Merge region area
    ImGui::InputFloat("Merge Region Area", &merge_region_area_);
    ImGui::SameLine();
    ::HelpMarker(
        "Merge region area, in square world units. Any navmesh region with a "
        "span count smaller than this value will, if possible, be merged with "
        "larger regions. Eventually expressed in terms of cell width.");
    if (merge_region_area_ != recast_params_->merge_region_area()) {
      has_difference = true;
    }

    // Max contour error
    ImGui::InputFloat("Max Contour Error", &max_contour_error_);
    ImGui::SameLine();
    ::HelpMarker(
        "The maximum distance a simplified contour's border edges should "
        "deviate the original raw contour. Eventually expressed in terms of "
        "cell width.");
    if (max_contour_error_ != recast_params_->max_contour_error()) {
      has_difference = true;
    }

    // Max edge length
    ImGui::InputFloat("Max Contour Edge Length", &max_edge_length_);
    ImGui::SameLine();
    ::HelpMarker(
        "Maximum length a contour's edge is allowed to have along the border "
        "of the mesh. Eventually expressed in terms of cell width.");
    if (max_edge_length_ != recast_params_->max_edge_length()) {
      has_difference = true;
    }

    // Detail sample distance
    ImGui::InputFloat("Detail Sample Distance", &detail_sample_distance_);
    ImGui::SameLine();
    ::HelpMarker(
        "Sample distance used to generate detail heightmap - lower values "
        "result in more granular height data being returned during "
        "navigation.");
    if (detail_sample_distance_ != recast_params_->detail_sample_distance()) {
      has_difference = true;
    }

    // Detail max error
    ImGui::InputFloat("Detail Max Error", &detail_max_error_);
    ImGui::SameLine();
    ::HelpMarker(
        "The maximum distance the detail mesh surface is allowed to deviate "
        "from the real heightfield data.");
    if (detail_max_error_ != recast_params_->detail_max_error()) {
      has_difference = true;
    }

    ImGui::TreePop();
  }

  // TODO (sessamekesh): continue here by expressing the list of RecastOps
  //  for an AssembleRecastNavMeshAction here. A new one can be added by
  //  selecting a type and filling in the required information before building.
  // Any incomplete/invalid sections should be highlighted in a light red color.
  if (ImGui::TreeNode("Recast Build Ops")) {
    if (ImGui::Button("Add build op")) {
      recast_ops_.push_back(
          indigo::igpackgen::pb::AssembleRecastNavMeshAction_RecastOp{});
    }

    auto stored_build_ops = recast_params_->recast_ops();

    if (stored_build_ops.size() != recast_ops_.size()) {
      has_difference = true;
    }

    for (int i = 0; i < recast_ops_.size(); i++) {
      auto& view_op = recast_ops_[i];
      if (stored_build_ops.size() <= i) {
        has_difference = true;
      } else if (!google::protobuf::util::MessageDifferencer::Equals(
                     view_op, stored_build_ops[i])) {
        has_difference = true;
      }

      if (view_op.op_case() ==
          indigo::igpackgen::pb::AssembleRecastNavMeshAction_RecastOp::OpCase::
              OP_NOT_SET) {
        view_op.mutable_include_assimp_geo();
      }

      //
      // Label of resource - change ordering in here also
      //
      std::string node_label = "";
      switch (view_op.op_case()) {
        case indigo::igpackgen::pb::AssembleRecastNavMeshAction_RecastOp::
            OpCase::kIncludeAssimpGeo:
          node_label = ::string_format("(%i) - Include Assimp Geo", i);
          break;
        case indigo::igpackgen::pb::AssembleRecastNavMeshAction_RecastOp::
            OpCase::kExcludeAssimpGeo:
          node_label = ::string_format("(%i) - Exclude Assimp Geo", i);
          break;
        default:
          validation_errors.push_back(::string_format(
              "Operation %i has invalid type - check proto", i));
          node_label = ::string_format("(%i) <<INVALID>>", i);
      }

      if (ImGui::TreeNode(node_label.c_str())) {
        ImGui::Text("...");
        if (i > 0) {
          ImGui::SameLine();
          if (ImGui::Button(::string_format("^##%i", i).c_str())) {
            indigo::igpackgen::pb::AssembleRecastNavMeshAction_RecastOp tmp =
                recast_ops_[i];
            recast_ops_[i] = recast_ops_[i - 1];
            recast_ops_[i - 1] = tmp;
          }
        }
        if (i < (recast_ops_.size() - 1)) {
          ImGui::SameLine();
          if (ImGui::Button(::string_format("v##%i", i).c_str())) {
            indigo::igpackgen::pb::AssembleRecastNavMeshAction_RecastOp tmp =
                recast_ops_[i];
            recast_ops_[i] = recast_ops_[i + 1];
            recast_ops_[i + 1] = tmp;
            Logger::log(kLogLabel) << "Moving up " << i;
          }
        }
        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(255, 10, 20, 255));
        if (ImGui::Button(::string_format("X##%i", i).c_str())) {
          delete_idx = i;
        }
        ImGui::PopStyleColor();

        //
        // Selectable type row - click button to change which type it is
        //
        {
          if (view_op.has_include_assimp_geo()) {
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(80, 80, 150, 255));
            ImGui::Button(::string_format("Include Assimp Geo##%i", i).c_str());
            ImGui::PopStyleColor();
          } else {
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(50, 50, 50, 255));
            if (ImGui::Button(
                    ::string_format("Include Assimp Geo##%i", i).c_str())) {
              view_op.mutable_include_assimp_geo();
            }
            ImGui::PopStyleColor();
          }

          ImGui::SameLine();

          if (view_op.has_exclude_assimp_geo()) {
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(80, 80, 150, 255));
            ImGui::Button(::string_format("Exclude Assimp Geo##%i", i).c_str());
            ImGui::PopStyleColor();
          } else {
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(50, 50, 50, 255));
            if (ImGui::Button(
                    ::string_format("Exclude Assimp Geo##%i", i).c_str())) {
              view_op.mutable_exclude_assimp_geo();
            }
            ImGui::PopStyleColor();
          }
        }

        //
        // Actual implementation of selectable
        //
        {
          if (view_op.has_include_assimp_geo()) {
            for (const auto& err : render_assimp_geo_def(
                     i, *view_op.mutable_include_assimp_geo())) {
              validation_errors.push_back(err);
            }
          }
          if (view_op.has_exclude_assimp_geo()) {
            for (const auto& err : render_assimp_geo_def(
                     i, *view_op.mutable_exclude_assimp_geo())) {
              validation_errors.push_back(err);
            }
          }
        }

        ImGui::Separator();
        ImGui::TreePop();
      }
    }

    ImGui::TreePop();
  }

  if (delete_idx >= 0 && delete_idx < recast_ops_.size()) {
    recast_ops_.erase(recast_ops_.begin() + delete_idx);
  }

  if (ImGui::TreeNode("Proto Text")) {
    if (ImGui::InputTextMultiline("##protosource", full_proto_text_,
                                  ::kFullProtoTextBufferSize)) {
      std::string t = full_proto_text_;
      text_matches_ = t == recast_params_->proto_text();
      has_text_error_ = false;
    }

    if (has_text_error_) {
      ImGui::TextColored(ImVec4(1.f, 0.1f, 0.1f, 1.f), "Invalid Proto");
    }

    if (!text_matches_) {
      if (ImGui::Button("Update Proto Text")) {
        std::string new_text = full_proto_text_;
        if (recast_params_->proto_text(new_text)) {
          sync_from_recast();
        } else {
          has_text_error_ = true;
          text_matches_ = false;
        }
      }
    }

    ImGui::TreePop();
  }

  if (has_difference) {
    if (validation_errors.size() == 0) {
      if (is_loading_) {
        ImGui::Text("Building...");
      } else {
        if (ImGui::Button("Build!")) {
          recast_params_->cell_size(cell_size_);
          recast_params_->cell_height(cell_height_);
          recast_params_->max_slope_degrees(max_slope_degrees_);
          recast_params_->walkable_climb(walkable_climb_);
          recast_params_->walkable_height(walkable_height_);
          recast_params_->agent_radius(agent_radius_);
          recast_params_->min_region_area(min_region_area_);
          recast_params_->merge_region_area(merge_region_area_);
          recast_params_->max_contour_error(max_contour_error_);
          recast_params_->max_edge_length(max_edge_length_);
          recast_params_->detail_sample_distance(detail_sample_distance_);
          recast_params_->detail_max_error(detail_max_error_);
          recast_params_->recast_ops(recast_ops_);

          sync_from_recast();
        }
      }
    } else {
      ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.f, 0.2f, 0.3f, 1.f));
      for (int i = 0; i < validation_errors.size(); i++) {
        ImGui::Text(validation_errors[i].c_str());
      }
      ImGui::PopStyleColor();
    }
  }
}

std::vector<std::string> NavMeshParamsView::render_assimp_geo_def(
    int i,
    indigo::igpackgen::pb::AssembleRecastNavMeshAction_AssimpGeoDef& geo_def) {
  std::vector<std::string> errs;

  if (ImGui::BeginListBox(::string_format("Assimp File List##%i", i).c_str())) {
    std::vector<std::string> file_names = assimp_loader_->file_names();

    for (const std::string& n : file_names) {
      std::error_code ec;
      std::string relative_path =
          std::filesystem::proximate(n, recast_params_->asset_root(), ec)
              .string();

      if (ec) {
        relative_path = n;
      }

      bool is_selected = geo_def.assimp_file_name() == relative_path;
      if (ImGui::Selectable(
              ::string_format("%s##%i", relative_path.c_str(), i).c_str(),
              is_selected)) {
        geo_def.set_assimp_file_name(relative_path);
      }
    }
    ImGui::EndListBox();
  }

  if (ImGui::BeginListBox(::string_format("Assimp Mesh List##%i", i).c_str())) {
    if (geo_def.assimp_file_name() == "") {
      ImGui::Selectable(::string_format("<<Empty>>##%i", i).c_str(), false);
    } else {
      std::string full_path =
          (std::filesystem::path(recast_params_->asset_root()) /
           geo_def.assimp_file_name())
              .string();

      std::vector<std::string> mesh_names =
          assimp_loader_->mesh_names_in_loaded_file(
              (recast_params_->asset_root() / geo_def.assimp_file_name())
                  .string());
      for (const std::string& n : mesh_names) {
        bool is_selected = geo_def.assimp_mesh_name() == n;
        if (ImGui::Selectable(::string_format("%s##%i", n.c_str(), i).c_str(),
                              is_selected)) {
          geo_def.set_assimp_mesh_name(n);
        }
      }
    }
    ImGui::EndListBox();
  }

  glm::vec3 pos(geo_def.position().x(), geo_def.position().y(),
                geo_def.position().z());
  glm::vec3 scl(geo_def.scale().x(), geo_def.scale().y(), geo_def.scale().z());
  if (!geo_def.has_scale()) {
    scl = glm::vec3(1.f, 1.f, 1.f);
  }
  glm::vec3 rot_axis(geo_def.rotation().x(), geo_def.rotation().y(),
                     geo_def.rotation().z());
  float rot_angle = geo_def.rotation().angle();
  if (!geo_def.has_rotation()) {
    rot_axis = glm::vec3(0.f, 1.f, 0.f);
    rot_angle = 0.f;
  }
  ImGui::InputFloat3("Position", &pos.x);
  ImGui::InputFloat3("Rotation Axis", &rot_axis.x);
  ImGui::InputFloat("Rotation Angle", &rot_angle);
  ImGui::InputFloat3("Scale", &scl.x);

  rot_axis = glm::normalize(rot_axis);
  geo_def.mutable_position()->set_x(pos.x);
  geo_def.mutable_position()->set_y(pos.y);
  geo_def.mutable_position()->set_z(pos.z);
  geo_def.mutable_rotation()->set_x(rot_axis.x);
  geo_def.mutable_rotation()->set_y(rot_axis.y);
  geo_def.mutable_rotation()->set_z(rot_axis.z);
  geo_def.mutable_rotation()->set_angle(rot_angle);
  geo_def.mutable_scale()->set_x(scl.x);
  geo_def.mutable_scale()->set_y(scl.y);
  geo_def.mutable_scale()->set_z(scl.z);

  ImGui::Text(
      ::string_format("File name: %s", geo_def.assimp_file_name().c_str())
          .c_str());
  ImGui::Text(
      ::string_format("Mesh name: %s", geo_def.assimp_mesh_name().c_str())
          .c_str());

  if (geo_def.assimp_file_name() == "") {
    errs.push_back(::string_format("No Assimp file name on resource %i", i));
  }
  if (geo_def.assimp_mesh_name() == "") {
    errs.push_back(::string_format("No Assimp mesh name on resource %i", i));
  }
  if (geo_def.scale().x() <= 0.f || geo_def.scale().y() <= 0.f ||
      geo_def.scale().z() <= 0.f) {
    errs.push_back(
        ::string_format("Assimp load %i cannot have scale of 0 or less", i));
  }

  return errs;
}

void NavMeshParamsView::sync_from_recast() {
  std::string ptt = recast_params_->proto_text();
  strcpy(full_proto_text_, ptt.c_str());
  text_matches_ = true;

  auto combiner = PromiseCombiner::Create();

  auto ops = recast_params_->recast_ops();
  for (const auto& op : ops) {
    if (op.has_include_assimp_geo()) {
      combiner->add(
          assimp_loader_->load_file((recast_params_->asset_root() /
                                     op.include_assimp_geo().assimp_file_name())
                                        .string(),
                                    async_task_list_, main_thread_task_list_),
          main_thread_task_list_);
    }
    if (op.has_exclude_assimp_geo()) {
      combiner->add(
          assimp_loader_->load_file((recast_params_->asset_root() /
                                     op.include_assimp_geo().assimp_file_name())
                                        .string(),
                                    async_task_list_, main_thread_task_list_),
          main_thread_task_list_);
    }
  }

  is_loading_ = true;
  combiner->combine()->on_success(
      [this](const auto&) {
        recast_ops_ = recast_params_->recast_ops();

        cell_size_ = recast_params_->cell_size();
        cell_height_ = recast_params_->cell_height();
        max_slope_degrees_ = recast_params_->max_slope_degrees();
        walkable_climb_ = recast_params_->walkable_climb();
        walkable_height_ = recast_params_->walkable_height();
        agent_radius_ = recast_params_->agent_radius();
        min_region_area_ = recast_params_->min_region_area();
        merge_region_area_ = recast_params_->merge_region_area();
        max_contour_error_ = recast_params_->max_contour_error();
        max_edge_length_ = recast_params_->max_edge_length();
        detail_sample_distance_ = recast_params_->detail_sample_distance();
        detail_max_error_ = recast_params_->detail_max_error();

        recast_builder_->rebuild_from(recast_params_, assimp_loader_);

        is_loading_ = false;
      },
      main_thread_task_list_);
}
